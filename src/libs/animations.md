# üìñ Informe Completo del Sistema de Animaciones

## üéØ Resumen Ejecutivo

Este documento analiza en detalle el sistema de animaciones implementado para la invitaci√≥n de cumplea√±os de Mateo. El sistema utiliza **GSAP (GreenSock Animation Platform)** como motor principal de animaciones y est√° dise√±ado para crear una experiencia inmersiva con navegaci√≥n horizontal entre secciones.

---

## üèóÔ∏è Arquitectura General

### üìÅ Estructura de Archivos
```
src/libs/
‚îú‚îÄ‚îÄ animations.ts      # L√≥gica principal de animaciones
‚îú‚îÄ‚îÄ animations.d.ts    # Definiciones de tipos TypeScript
‚îî‚îÄ‚îÄ animations.md      # Este documento de an√°lisis
```

### üîß Dependencias Principales
- **GSAP Core**: Motor de animaciones
- **ScrollTrigger**: Plugin para animaciones basadas en scroll
- **Observer**: Plugin para detecci√≥n de gestos (swipe)
- **ScrollToPlugin**: Plugin para navegaci√≥n suave

---

## üìä An√°lisis de Tipos (animations.d.ts)

### `HeroAnimationsProps`
```typescript
export type HeroAnimationsProps = {
    heroSection?: HTMLElement;    // Contenedor principal del hero
    video?: HTMLVideoElement;     // Elemento de video de fondo
    logo?: HTMLElement;          // Logo de Spider-Man
    heroShadow?: HTMLElement;    // Gradiente de sombra
    arrowDown?: HTMLElement;     // Flecha indicadora de scroll
}
```

### `SectionsAnimationsProps`
```typescript
export type SectionsAnimationsProps = {
    main?: HTMLElement;          // Contenedor principal de secciones
    container?: HTMLElement;     // Contenedor deslizable
    sections?: HTMLElement[];    // Array de secciones individuales
}
```

### `SectionsController`
**Objeto central** que encapsula toda la l√≥gica de navegaci√≥n entre secciones:

#### Variables de Estado
- `currentSection`: √çndice de la secci√≥n actualmente visible
- `isAnimating`: Flag para prevenir animaciones simult√°neas
- `isScrolling`: Flag para detectar estado de scroll activo
- `sectionsLength`: N√∫mero total de secciones
- `timeline`: Referencia al timeline principal de GSAP
- `scrollTimeout`: Timeout para detectar fin de scroll

#### M√©todos Principales
- `isInitialized()`: Verifica si el controlador est√° listo
- `getNearestSection()`: Calcula la secci√≥n m√°s cercana
- `goToSection()`: Navega a una secci√≥n espec√≠fica
- `goToNearestSection()`: Navegaci√≥n direccional unificada
- `handleScroll()`: Maneja la detecci√≥n de scroll
- `init()`: Inicializa todo el sistema
- `destroy()`: Limpia recursos

---

## üéÆ An√°lisis Funcional Detallado

### 1. **Sistema de Configuraci√≥n**

#### `setHeroAnimation(props: HeroAnimationsProps)`
- **Prop√≥sito**: Configurar elementos del DOM para animaciones del hero
- **Implementaci√≥n**: Usa `Object.assign()` para actualizar `HeroProps`
- **Timing**: Se ejecuta en `DOMContentLoaded` desde `Hero.astro`

#### `setSectionsAnimation(props: SectionsAnimationsProps)`
- **Prop√≥sito**: Configurar elementos para animaciones de secciones
- **Implementaci√≥n**: Actualiza tanto `SectionsProps` como `sectionsController.props`
- **Timing**: Se ejecuta en `DOMContentLoaded` desde `Sections.astro`

### 2. **SectionsController - An√°lisis Profundo**

#### `getNearestSection(progress: number): number`
```typescript
const sectionProgress = progress * (this.sectionsLength - 1);
return Math.round(sectionProgress);
```

**¬øQu√© hace realmente esta funci√≥n?**

Imag√≠nate que tienes 4 secciones en tu p√°gina y el usuario est√° haciendo scroll. GSAP te dice "oye, el usuario est√° en el 65% del recorrido total". Pero t√∫ necesitas saber "¬øen qu√© secci√≥n espec√≠fica deber√≠a estar?".

Esta funci√≥n toma ese porcentaje (0.65) y lo convierte en un n√∫mero de secci√≥n real:
- Si tienes 4 secciones, los √≠ndices van de 0 a 3
- 0.65 √ó 3 = 1.95
- `Math.round(1.95)` = 2 (secci√≥n n√∫mero 2)

Es como un traductor entre "porcentaje de scroll" y "n√∫mero de secci√≥n". Super √∫til para el sistema de snap.

#### `goToSection(index: number)` - La Funci√≥n de Navegaci√≥n Principal

Esta es **la funci√≥n m√°s importante** del sistema. Es como el conductor del autob√∫s que lleva a los usuarios de una secci√≥n a otra.

**Flujo paso a paso:**

1. **üö® Validaciones de Seguridad**
   ```typescript
   if (this.isAnimating || !this.timeline || this.sectionsLength === 0) return;
   ```
   Piensa en esto como un sistema de seguridad: "¬øYa hay una animaci√≥n corriendo? ¬øEst√° todo inicializado? ¬øHay secciones para navegar?". Si algo falla, mejor no hacer nada.

2. **üîí Activar el Candado**
   ```typescript
   this.isAnimating = true;
   ```
   Esto es como poner un letrero de "OCUPADO" para que nadie m√°s pueda iniciar otra animaci√≥n mientras esta est√° corriendo.

3. **üßÆ Matem√°tica de Conversi√≥n**
   ```typescript
   const progress = index / (this.sectionsLength - 1);
   ```
   Aqu√≠ convertimos el n√∫mero de secci√≥n a un porcentaje. Si quieres ir a la secci√≥n 2 de 4 total:
   - `2 / (4 - 1) = 2 / 3 = 0.666...`
   - Esto significa "ve al 66% del recorrido total"

4. **üìè Mapeo de Posici√≥n Real**
   ```typescript
   const targetScroll = gsap.utils.mapRange(0, 1, scrollTrigger.start, scrollTrigger.end, progress);
   ```
   Esto es donde la magia sucede. GSAP tiene una funci√≥n que dice: "OK, si 0% del progreso equivale a scroll posici√≥n X, y 100% equivale a posici√≥n Y, entonces 66% equivale a posici√≥n Z". Es como usar una regla de tres matem√°tica pero autom√°tica.

5. **üé¨ La Animaci√≥n**
   ```typescript
   gsap.to(window, {
       scrollTo: targetScroll,
       duration: 0.6,
       ease: "power2.out",
       onComplete: () => { this.isAnimating = false; }
   });
   ```
   Finalmente, le decimos al navegador: "mu√©vete suavemente a esta posici√≥n en 0.6 segundos, y cuando termines, quita el letrero de OCUPADO".

#### `goToNearestSection(direction)` - El Cerebro de la Navegaci√≥n

Esta funci√≥n es como un **mayordomo inteligente** que entiende diferentes tipos de √≥rdenes y las traduce a acciones espec√≠ficas.

**Modes de Operaci√≥n explicados:**

**Modo N√∫mero Espec√≠fico:**
```typescript
if (typeof direction === 'number') {
    targetSection = Math.max(0, Math.min(direction, this.sectionsLength - 1));
}
```
Cuando le dices "ve a la secci√≥n 5", pero solo tienes 4 secciones, el mayordomo es inteligente y dice "OK, te llevo a la secci√≥n 3 (la √∫ltima que existe)". Tambi√©n funciona al rev√©s: si pides ir a la secci√≥n -2, te lleva a la 0.

**Modo Direccional:**
```typescript
case 'next':
    targetSection = Math.min(this.currentSection + 1, this.sectionsLength - 1);
case 'prev':
    targetSection = Math.max(this.currentSection - 1, 0);
```
Aqu√≠ el mayordomo piensa: "Est√°s en la secci√≥n 2, quieres ir 'next', entonces te llevo a la 3. Pero si ya est√°s en la √∫ltima, me quedo donde estoy para no romperte la experiencia".

#### `init()` - El Constructor del Mundo

Esta funci√≥n es como **construir toda una ciudad desde cero**. Vamos paso a paso:

**1. üèóÔ∏è Verificaci√≥n del Terreno**
```typescript
if (!this.props.main || !this.props.container || !this.props.sections) {
    throw new Error("No tengo los materiales de construcci√≥n!");
}
```

**2. üìã Planificaci√≥n Urbana**
```typescript
this.sectionsLength = numSections;
this.currentSection = 0;
```
"OK, vamos a construir una ciudad de 4 barrios, empezamos en el barrio 0"

**3. üé® Dise√±o Arquitect√≥nico**
```typescript
container.style.width = `${numSections * 100}vw`;
container.style.backgroundSize = `calc(115% / ${numSections}) auto`;
```
Aqu√≠ viene lo interesante: si tienes 4 secciones, el contenedor ser√° de `400vw` (4 √ó 100vw). Es como crear un papel super ancho donde cada secci√≥n ocupa exactamente el ancho de la pantalla. El background se divide proporcionalmente.

**4. üöÇ Construcci√≥n del Tren Principal (Timeline)**
```typescript
const tl = gsap.to(container, {
    x: () => `-${container.scrollWidth - main.clientWidth}px`,
    scrollTrigger: { /* configuraci√≥n compleja */ }
});
```
Esto es **EL CORAZ√ìN** del sistema. Le dice a GSAP: "Cuando el usuario haga scroll, mueve este contenedor horizontalmente". La f√≥rmula `container.scrollWidth - main.clientWidth` significa "mu√©velo desde su posici√≥n inicial hasta que la √∫ltima secci√≥n est√© visible".

**5. üì± Sistema de Detecci√≥n T√°ctil**
```typescript
Observer.create({
    target: main,
    type: "touch",
    tolerance: 30,
    onRight: () => { /* ir a anterior */ },
    onLeft: () => { /* ir a siguiente */ }
});
```
Este es el cerebro que entiende cuando alguien desliza el dedo. "Tolerance: 30" significa "necesitas mover el dedo al menos 30 p√≠xeles para que lo considere un swipe real, no un toque accidental".

### 3. **Sistema de ScrollTrigger - El Director de Orquesta**

ScrollTrigger es como **el director de una orquesta sinf√≥nica**. Coordina cu√°ndo y c√≥mo suceden las cosas bas√°ndose en la posici√≥n del scroll del usuario.

#### Configuraci√≥n Principal - Explicada Humana
```typescript
scrollTrigger: {
    trigger: main,                    // "Vigila este elemento"
    start: "top top",                // "Empieza cuando llegue arriba del todo"
    end: () => `+=${container.scrollWidth - main.clientWidth}`,
    scrub: 0.5,                      // "S√≠gueme suavemente"
    pin: true,                       // "Mant√©n esto fijo mientras trabajo"
    anticipatePin: 1,                // "Prep√°rate un poquito antes"
    invalidateOnRefresh: true,       // "Si cambia el tama√±o, recalcula todo"
    snap: { /* configuraci√≥n de snap */ }
}
```

**Vamos a desglosar cada parte:**

**`trigger: main`**: Le dice a GSAP "vigila este elemento espec√≠fico". Cuando este elemento entre o salga del viewport, es cuando las cosas van a pasar.

**`start: "top top"`**: Esta es una sintaxis especial de GSAP que significa "cuando el top del elemento trigger toque el top del viewport". Es como decir "cuando el elemento llegue completamente arriba de la pantalla".

**`end: () => container.scrollWidth - main.clientWidth`**: Aqu√≠ viene lo interesante. Esta funci√≥n calcula din√°micamente cu√°ndo debe terminar la animaci√≥n. Si tu contenedor mide 400vw (4 secciones √ó 100vw cada una) y tu pantalla es 100vw, entonces el end ser√° en 300vw m√°s adelante. Es decir, "termina cuando hayamos scrolleado lo suficiente para ver la √∫ltima secci√≥n".

**`scrub: 0.5`**: Este es **s√∫per importante**. Significa "vincula la animaci√≥n directamente con el scroll, pero hazlo suave". El 0.5 es como decir "no seas tan brusco, dale un poquito de inercia". Si fuera 1, ser√≠a m√°s suave pero lento. Si fuera 0.1, ser√≠a m√°s inmediato pero puede sentirse rob√≥tico.

**`pin: true`**: Esto es **magia pura**. Le dice a GSAP "mientras esta animaci√≥n est√° corriendo, mant√©n este elemento fijo en la pantalla". Sin esto, el usuario scrollear√≠a normalmente hacia abajo. Con esto, el scroll se "convierte" en movimiento horizontal.

#### Sistema de Snap - El Magnetismo Inteligente
```typescript
snap: {
    snapTo: (value) => {
        this.currentSection = this.getNearestSection(value);
        return this.currentSection / (this.sectionsLength - 1);
    },
    duration: 0.3,                   // "T√≥mate 0.3 segundos para llegar"
    ease: "power2.out",              // "Empieza r√°pido, termina suave"
    delay: 0.1,                      // "Espera un poquito antes de decidir"
    directional: false               // "Funciona en ambas direcciones"
}
```

**¬øC√≥mo funciona el snap?**

Imag√≠nate que el scroll es como caminar por un pasillo con imanes invisibles cada cierta distancia. Cuando el usuario para de hacer scroll:

1. **El sistema pregunta**: "¬øD√≥nde est√° el usuario ahora?" (recibe un `value` entre 0 y 1)
2. **Calcula la secci√≥n m√°s cercana**: Usa `getNearestSection()` para decidir "deber√≠a estar en la secci√≥n 2"
3. **Convierte de vuelta a porcentaje**: `2 / (4-1) = 0.666...`
4. **Anima suavemente**: "Mu√©vete al 66.6% del recorrido en 0.3 segundos"

**`delay: 0.1`** es crucial: espera 100ms antes de decidir hacer snap. Esto evita que si el usuario hace scroll muy r√°pido, el sistema no est√© "saltando" constantemente entre secciones.

### 4. **Sistema de Detecci√≥n de Gestos**

#### Observer Configuration
```typescript
Observer.create({
    target: main,                    // Elemento objetivo
    type: "touch",                   // Tipo de input
    tolerance: 30,                   // Sensibilidad del gesto
    onRight: () => { /* ir a anterior */ },
    onLeft: () => { /* ir a siguiente */ }
});
```

---

## üé¨ An√°lisis de Animaciones del Hero - El Espect√°culo de Bienvenida

### `initHeroAnimation()` - El Core√≥grafo Principal

Esta funci√≥n es como **el director de una obra de teatro**. Coordina 5 "actores" diferentes (video, logo, sombra, flecha) para crear una experiencia cinematogr√°fica. Vamos a ver cada "acto":

#### 1. **Control de Video - El Actor Principal** üé•
```typescript
ScrollTrigger.create({
    trigger: heroSection,
    start: "50% top",
    end: "50% bottom",
    onLeave: () => video.pause(),
    onLeaveBack: () => video.play(),
});
```

**¬øQu√© est√° pasando aqu√≠?**

Imag√≠nate que el video es como una TV en un bar. Cuando est√°s cerca (en la secci√≥n hero), la TV est√° encendida y reproduciendo. Cuando te alejas (scrolleas hacia las secciones), la TV se pausa autom√°ticamente para ahorrar recursos.

- `start: "50% top"`: "Cuando la mitad de la secci√≥n hero llegue al top de la pantalla"
- `onLeave`: "Si el usuario se va de esta zona, pausa el video"
- `onLeaveBack`: "Si el usuario regresa, reanuda el video"

Es una optimizaci√≥n s√∫per inteligente: ¬øpara qu√© gastar bater√≠a reproduciendo un video que nadie est√° viendo?

#### 2. **Animaci√≥n del Logo - La Estrella del Show** üï∑Ô∏è
```typescript
gsap.from(logo, {
    opacity: 0,
    scale: 0.7,              // ‚ö†Ô∏è Nota: hay un typo "sacale" en el c√≥digo original
    duration: 4,
    delay: 3.5,
    onComplete: () => {
        // Segunda fase: animaci√≥n de salida
        gsap.to(logo, {
            opacity: 0,
            y: -50,
            scale: 0.8,
            scrollTrigger: { /* configuraci√≥n */ }
        });
    }
});
```

**La historia del logo en dos actos:**

**Acto 1 - La Gran Entrada (3.5s + 4s = 7.5s total):**
- Usuario llega a la p√°gina
- Espera 3.5 segundos (tiempo para que se cargue todo)
- Durante los siguientes 4 segundos: el logo aparece gradualmente y crece desde el 70% hasta su tama√±o normal
- Es como un superh√©roe apareciendo lentamente con su traje

**Acto 2 - La Despedida Elegante:**
- Cuando el usuario hace scroll para irse
- El logo se desvanece, se mueve hacia arriba y se encoge un poquito
- Es como decir "adi√≥s, nos vemos en la pr√≥xima aventura"

**Problema detectado**: En el c√≥digo original dice `sacale: 0.7` pero deber√≠a ser `scale: 0.7`. ¬°Un peque√±o typo que podr√≠a estar causando problemas!

#### 3. **Animaci√≥n de Sombra - El Efecto Cinematogr√°fico** üåë
```typescript
gsap.fromTo(heroShadow, 
    { opacity: 0 },
    {
        scrollTrigger: {
            start: "center 30%",
            end: "center top",
            scrub: true
        },
        opacity: 1
    }
);
```

**¬øQu√© hace esta sombra?**

Esta es **pura magia cinematogr√°fica**. La sombra es un gradiente negro que va de transparente a opaco. Cuando el usuario empieza a hacer scroll:

- Al principio: sombra invisible (opacity: 0)
- Mientras scrollea: sombra aparece gradualmente
- Al final: sombra completamente visible (opacity: 1)

El efecto visual es como si **una cortina oscura fuera cayendo lentamente** sobre el video, preparando la transici√≥n hacia las siguientes secciones. Es el equivalente digital de "fade to black" en el cine.

#### 4. **Animaci√≥n del Video - Efecto Parallax** üé•
```typescript
gsap.to(video, {
    scrollTrigger: {
        start: "center 26%",
        end: "bottom top",
        scrub: true,
    },
    y: '+=300'                       // Mueve el video 300px hacia abajo
});
```

**El truco del parallax explicado:**

Mientras el usuario scrollea hacia abajo, el video **tambi√©n se mueve hacia abajo, pero m√°s lentamente** que el scroll normal. Esto crea una ilusi√≥n √≥ptica super cool:

- El usuario scrollea 1000px hacia abajo
- El video solo se mueve 300px hacia abajo
- Resultado: parece que el video se "queda atr√°s" creando profundidad

Es el mismo efecto que ves cuando viajas en auto: las monta√±as lejanas se mueven m√°s lento que los √°rboles cercanos.

#### 5. **Animaci√≥n de Flecha - La Gu√≠a del Usuario** ‚¨áÔ∏è
```typescript
gsap.to(arrowDown, {
    opacity: .85,
    y: -50,
    duration: 5,
    delay: 7,                        // Aparece 7 segundos despu√©s de cargar
    onComplete: () => {
        // Fade out cuando el usuario hace scroll
        gsap.to(arrowDown, {
            scrollTrigger: { /* configuraci√≥n */ },
            opacity: 0
        });
    }
});
```

**La flecha como gu√≠a tur√≠stica:**

1. **Timing perfecto**: Aparece despu√©s de 7 segundos, justo cuando el usuario ya vio el logo y puede estar pregunt√°ndose "¬øy ahora qu√©?"
2. **Movimiento sutil**: Se mueve 50px hacia arriba mientras aparece, como diciendo "¬°hey, m√≠rame!"
3. **Duraci√≥n larga**: Toma 5 segundos en aparecer completamente, no es brusca
4. **Desaparici√≥n inteligente**: En cuanto detecta que el usuario hace scroll, se desvanece porque ya cumpli√≥ su prop√≥sito

#### 6. **Interactividad de Flecha - El Acceso Directo**
```typescript
arrowDown.addEventListener("click", () => {
    if (sectionsNavigator) {
        sectionsNavigator(0);        // Va directamente a la primera secci√≥n
    } else {
        // Plan B: scrolleo manual
        gsap.to(window, {
            scrollTo: { y: "#mainSection" }
        });
    }
});
```

**Dos niveles de seguridad:**

1. **Plan A**: Usa el sistema inteligente de navegaci√≥n (que respeta todas las animaciones y estados)
2. **Plan B**: Si por alguna raz√≥n el sistema no est√° listo, hace un scroll directo al elemento

Es como tener un ascensor moderno con botones digitales, pero tambi√©n escaleras por si se va la luz.

---

## üîÑ Flujo de Inicializaci√≥n - La Secuencia de Arranque

### Secuencia de Ejecuci√≥n - Como Encender una Nave Espacial

Imag√≠nate que inicializar las animaciones es como **preparar una nave espacial para el despegue**. Hay un orden espec√≠fico y cada paso depende del anterior:

```mermaid
graph TD
    A[Modal.astro - Button Click] --> B[initAnimations()]
    B --> C[gsap.registerPlugin()]
    C --> D[initSectionsAnimation()]
    D --> E[sectionsController.init()]
    E --> F[initHeroAnimation()]
    F --> G[Sistema Listo]
```

#### 1. **Trigger Inicial** (Modal.astro) - El Bot√≥n Rojo
```typescript
button.addEventListener("click", () => {
    modal.classList.add("hidden");                          // Quita la pantalla de bienvenida
    document.body.classList.remove("overflow-hidden");      // Permite el scroll
    initAnimations();                                        // üöÄ DESPEGUE!
    introduccionAudio.play();                               // Empieza la m√∫sica
});
```

**¬øPor qu√© es importante este momento?**

Hasta que el usuario no presiona el bot√≥n, la p√°gina tiene `overflow: hidden` en el body. Esto significa que **GSAP no puede calcular correctamente las distancias de scroll** porque t√©cnicamente "no hay scroll disponible". 

Es como tratar de medir una carretera mientras est√° cubierta de nieve: hasta que no se quita la nieve (`overflow: hidden`), no puedes saber qu√© tan larga es realmente.

#### 2. **Registro de Plugins** - Preparando las Herramientas
```typescript
export const initAnimations = () => {
    gsap.registerPlugin(ScrollTrigger, Observer, ScrollToPlugin);
    // ... resto de inicializaci√≥n
}
```

**¬øPor qu√© primero los plugins?**

GSAP tiene un sistema modular. El core de GSAP puede animar opacity, scale, position, etc. Pero funcionalidades especiales como "animar basado en scroll" o "detectar swipes" vienen en plugins separados.

Es como tener una caja de herramientas b√°sica, pero para trabajos espec√≠ficos necesitas herramientas especializadas. Tienes que "registrar" (instalar) estas herramientas antes de poder usarlas.

#### 3. **Orden de Inicializaci√≥n - Por Qu√© Secciones Primero**
```typescript
try {
    initSectionsAnimation(); // ü•á Primero las secciones
    initHeroAnimation();     // ü•à Despu√©s el hero
} catch (error) {
    console.error("Error initializing animations:", error);
}
```

**¬øPor qu√© este orden espec√≠fico?**

1. **`initSectionsAnimation()` primero**: 
   - Inicializa el `sectionsController`
   - Crea el `sectionsNavigator` global
   - Establece todo el sistema de navegaci√≥n

2. **`initHeroAnimation()` despu√©s**:
   - Puede usar `sectionsNavigator` en el click de la flecha
   - Depende de que el sistema de secciones est√© listo

Es como construir una casa: primero pones los cimientos (secciones), despu√©s instalas las ventanas (hero que puede "mirar" hacia las secciones).

### El Problema del Timing - Por Qu√© el Orden Importa

**Escenario A (‚ùå Malo)**: Hero primero, secciones despu√©s
```typescript
initHeroAnimation();    // Crea el click handler de la flecha
initSectionsAnimation(); // Crea sectionsNavigator
// Problema: cuando se cre√≥ el click handler, sectionsNavigator era null!
```

**Escenario B (‚úÖ Bueno)**: Secciones primero, hero despu√©s
```typescript
initSectionsAnimation(); // Crea sectionsNavigator
initHeroAnimation();     // El click handler encuentra sectionsNavigator ya listo
// ¬°Perfecto! Todo funciona
```

### La Danza de los Componentes Astro

Cada componente Astro se "presenta" al sistema en el momento correcto:

#### Hero.astro - El Protagonista
```typescript
document.addEventListener("DOMContentLoaded", () => {
    setHeroAnimation({
        heroSection: document.getElementById("heroSection"),
        video: document.querySelector("video"),
        logo: document.getElementById("logo"),
        heroShadow: document.getElementById("sombra"),
        arrowDown: document.getElementById("arrow-down"),
    });
});
```

**Timing**: Se ejecuta cuando el DOM est√° listo, pero **antes** de que se inicialicen las animaciones. Es como los actores llegando al teatro y dici√©ndole al director "estoy aqu√≠, estos son mis props".

#### Sections.astro - El Escenario
```typescript
document.addEventListener("DOMContentLoaded", () => {
    setSectionsAnimation({
        main: document.getElementById("mainSection"),
        container: document.getElementById("container"),
        sections: Array.from(document.querySelectorAll("section")),
    });
});
```

**Peculiaridad importante**: `sections` se obtiene con `querySelectorAll("section")`, lo que significa que **autom√°ticamente detecta cu√°ntas secciones hay**. Si ma√±ana agregas una quinta secci√≥n en el HTML, el sistema autom√°ticamente se adapta.

#### Modal.astro - El Director General
- **Control del overflow**: Maneja cu√°ndo se puede hacer scroll
- **Orquestaci√≥n**: Decide cu√°ndo arranca todo el show
- **Audio**: Coordina la m√∫sica de fondo

Es como el director de una √≥pera que coordina la orquesta, los cantantes, y las luces.

---

## üéØ Integraci√≥n con Componentes Astro

### Hero.astro
```typescript
document.addEventListener("DOMContentLoaded", () => {
    setHeroAnimation({
        heroSection: document.getElementById("heroSection"),
        video: document.querySelector("video"),
        logo: document.getElementById("logo"),
        heroShadow: document.getElementById("sombra"),
        arrowDown: document.getElementById("arrow-down"),
    });
});
```
- **Timing**: `DOMContentLoaded` - Elementos ya disponibles
- **Configuraci√≥n**: Mapeo directo de IDs a propiedades

### Sections.astro
```typescript
document.addEventListener("DOMContentLoaded", () => {
    setSectionsAnimation({
        main: document.getElementById("mainSection"),
        container: document.getElementById("container"),
        sections: Array.from(document.querySelectorAll("section")),
    });
});
```
- **Peculiaridad**: `sections` se obtiene como array de todos los `<section>`

### Modal.astro (Orquestador)
- **Responsabilidad**: Controlar el flujo de inicio
- **Estado Inicial**: `overflow-hidden` en body
- **Trigger**: Click del bot√≥n inicia todo el sistema

---

## ‚ö° Optimizaciones de Performance

### 1. **Configuraciones GSAP**
- `scrub: 0.5`: Balance entre suavidad y responsividad
- `anticipatePin: 1`: Pre-c√°lculo para mejor performance
- `invalidateOnRefresh: true`: Recalcular en resize

### 2. **Timeouts Optimizados**
- `scrollTimeout: 100ms`: Detecci√≥n r√°pida de fin de scroll
- `snap.delay: 0.1`: Previene snaps muy agresivos

### 3. **Gesti√≥n de Estado**
- `isAnimating`: Previene animaciones simult√°neas
- `isScrolling`: Mejor control de interacciones

---

## üêõ Issues Identificados

### 1. **Typo en Logo Animation**
```typescript
// ‚ùå Error
sacale: 0.7,

// ‚úÖ Correcto
scale: 0.7,
```

### 2. **Potencial Memory Leak**
```typescript
// Event listener sin cleanup espec√≠fico
window.addEventListener('scroll', () => this.handleScroll());
```

### 3. **Hardcoded Selectors**
- Dependencia de IDs espec√≠ficos
- Podr√≠a ser m√°s flexible con data-attributes

---

## üìà M√©tricas de Performance

### Configuraciones Actuales
- **Snap Duration**: 0.3s (optimizado desde 0.5s)
- **Scroll Scrub**: 0.5 (optimizado desde 1.0)
- **Swipe Tolerance**: 30px (optimizado desde 50px)
- **Scroll Detection**: 100ms timeout

### Animaciones Hero
- **Logo Entry**: 4s duration + 3.5s delay = 7.5s total
- **Arrow Appearance**: 5s duration + 7s delay = 12s total
- **All Scrub-based**: Vinculadas al scroll del usuario

---

## üîÆ Consideraciones Futuras

### 1. **Sistema Modular**
- Separar animaciones por componente
- Factory pattern para diferentes tipos de secci√≥n

### 2. **Configuraci√≥n Externa**
- JSON/YAML para timing y configuraciones
- A/B testing de duraciones

### 3. **Accessibility**
- `prefers-reduced-motion` support
- Configuraciones de velocidad

### 4. **Analytics**
- Tracking de interacciones
- M√©tricas de engagement por secci√≥n

---

## üìù Conclusiones

El sistema de animaciones est√° **bien estructurado** y utiliza las mejores pr√°cticas de GSAP. La arquitectura del `SectionsController` es s√≥lida y permite extensibilidad futura. 

**Fortalezas:**
- ‚úÖ Encapsulaci√≥n clara de responsabilidades
- ‚úÖ Performance optimizada
- ‚úÖ Integraci√≥n limpia con Astro
- ‚úÖ Manejo robusto de estados

**√Åreas de Mejora:**
- üîß Corregir typo en animaci√≥n del logo
- üîß Mejorar cleanup de event listeners
- üîß Considerar configuraciones m√°s flexibles

El sistema est√° **listo para producci√≥n** y proporciona una base s√≥lida para la experiencia inmersiva deseada en la invitaci√≥n de cumplea√±os.
